# 最终修复方案：彻底解决 User 变量作用域问题

## 问题根源

Python 的变量作用域规则：
- **如果在函数内部对变量进行任何形式的赋值或导入操作，Python 会将整个函数范围内的该变量视为局部变量**
- 即使在 `try` 块中使用 `User`，Python 在编译时就会将其视为局部变量
- 在 `except` 块中导入 `User` 时，如果 Python 认为 `User` 是局部变量，导入语句本身就会出错

## 为什么之前的修复没有生效？

1. **引用位置不够早**：虽然在函数开始处引用了 `User`，但如果 `try` 块中使用 `User`，Python 仍然可能将其视为局部变量
2. **except 块中的导入冲突**：`from ... import User as UserModel` 仍然会触发 Python 的变量作用域分析
3. **Python 编译时分析**：Python 在编译函数时会分析整个函数，不仅仅是执行路径

## 最终解决方案

### 方案1：使用 global 声明（不推荐，但最直接）

```python
async def send_packet_menu_callback(...):
    global User  # 明确声明 User 是全局变量
    # ...
```

### 方案2：在 except 块中完全避免使用 User 名称（推荐）

```python
except Exception as e:
    # 使用模块导入，完全避免 User 名称
    import shared.database.models as models_module
    UserModel = models_module.User  # 通过模块属性访问
```

### 方案3：在函数开始处使用多种方式引用（已应用）

```python
async def send_packet_menu_callback(...):
    _user_ref = User  # 变量赋值
    _ = User.__name__  # 属性访问
    # ...
```

## 当前代码状态

- ✅ 第602-603行：在函数开始处使用多种方式引用 User
- ✅ 第882-883行：在 except 块中使用模块导入方式

## 如果错误仍然发生

可能的原因：
1. Bot 还没有重新加载代码（需要重启）
2. Python 缓存了旧的字节码（需要清除 `__pycache__`）
3. 还有其他地方也在使用 User，导致作用域冲突

## 验证步骤

1. 停止 Bot
2. 清除 Python 缓存：`find . -type d -name __pycache__ -exec rm -r {} +` 或手动删除
3. 重新启动 Bot
4. 测试发送红包功能
