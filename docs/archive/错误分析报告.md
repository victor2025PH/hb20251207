# 错误分析报告：`cannot access local variable 'User'`

## 错误信息
```
ERROR: bot.handlers.packets:send_packet_menu_callback:867 - [SEND_PACKET] Error processing callback: cannot access local variable 'User' where it is not associated with a value
```

## 根本原因分析

### 1. Python 变量作用域规则

Python 有一个特殊的规则：**如果在函数内部对变量进行赋值操作，Python 会将整个函数范围内的该变量视为局部变量**。

### 2. 问题代码结构

在 `send_packet_menu_callback` 函数中：

```python
async def send_packet_menu_callback(...):
    # 第621行：在函数内部导入 User
    from shared.database.models import User
    
    try:
        # ... 各种操作 ...
        
        # 第833行：在 confirm 分支中使用 User
        with get_db() as db:
            fresh_db_user = db.query(User).filter(User.tg_id == user_id).first()
        
        # 第853行：在 amount_custom 分支中使用 User
        with get_db() as db:
            db_user = db.query(User).filter(User.tg_id == user_id).first()
            
    except Exception as e:
        # 第871行：在 except 块中尝试导入 User
        from shared.database.models import User as UserModel
```

### 3. 为什么会出现错误？

**关键问题**：虽然代码中没有 `User = ...` 这样的直接赋值，但 Python 的编译器在分析代码时发现：

1. 在 `try` 块中，`User` 被使用了（第833行和第853行）
2. 在 `except` 块中，也有对 `User` 的引用（虽然使用了别名 `UserModel`）
3. Python 可能将 `User` 视为局部变量，因为它在函数内部被导入和使用

**更可能的原因**：
- 如果在 `try` 块执行到使用 `User` 的代码之前就发生异常
- 或者在某个地方有对 `User` 的赋值操作（即使是在条件分支中）
- Python 会认为 `User` 是一个局部变量
- 但在 `except` 块中访问时，如果 `User` 还没有被赋值，就会出现这个错误

### 4. 为什么一直没有修改好？

1. **问题定位不准确**：
   - 之前的修复主要集中在 SQLAlchemy 会话管理
   - 没有意识到这是 Python 变量作用域的问题

2. **修复不彻底**：
   - 虽然使用了 `UserModel` 别名，但 `User` 仍然在函数顶部被导入
   - 在 `try` 块中仍然使用 `User`，导致 Python 将其视为局部变量

3. **测试不充分**：
   - 错误只在特定条件下出现（在 `confirm` 分支执行前发生异常）
   - 可能没有覆盖到这个特定的错误路径

## 解决方案

### 方案1：将 User 导入移到文件顶部（推荐）

```python
# 在文件顶部（第14行）
from shared.database.models import User, RedPacket, RedPacketClaim, ...

# 在函数中不再导入 User
async def send_packet_menu_callback(...):
    # 不再需要导入 User
    from shared.database.connection import get_db
    
    try:
        # 直接使用 User（从文件顶部导入）
        with get_db() as db:
            fresh_db_user = db.query(User).filter(User.tg_id == user_id).first()
```

### 方案2：在函数内部使用别名（当前方案）

```python
async def send_packet_menu_callback(...):
    # 使用别名避免冲突
    from shared.database.models import User as UserModel
    from shared.database.connection import get_db
    
    try:
        # 使用别名
        with get_db() as db:
            fresh_db_user = db.query(UserModel).filter(UserModel.tg_id == user_id).first()
```

### 方案3：在 except 块中完全重新导入

```python
except Exception as e:
    # 完全重新导入，使用不同的名称
    import sys
    from shared.database.models import User as UserModel
    # 确保 UserModel 可用
```

## 推荐修复方案

**最佳方案**：由于 `User` 已经在文件顶部导入（第14行），应该：
1. 移除函数内部的 `User` 导入（第621行）
2. 在函数中直接使用从文件顶部导入的 `User`
3. 在 `except` 块中使用 `UserModel` 别名，避免任何潜在的冲突

这样可以：
- 避免变量作用域问题
- 保持代码一致性
- 减少重复导入
