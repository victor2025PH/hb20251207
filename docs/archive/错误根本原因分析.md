# 错误根本原因分析：`cannot access local variable 'User'`

## 错误信息
```
ERROR: bot.handlers.packets:send_packet_menu_callback:871 - [SEND_PACKET] Error processing callback: cannot access local variable 'User' where it is not associated with a value
```

## 问题分析

### 1. Python 变量作用域规则（关键！）

Python 有一个**编译时**的变量作用域分析规则：

**如果在函数内部对变量进行任何形式的赋值或导入操作，Python 会将整个函数范围内的该变量视为局部变量。**

这包括：
- 直接赋值：`User = ...`
- 在 `try` 块中使用：`db.query(User)...`
- 在 `except` 块中导入：`from ... import User`

### 2. 当前代码的问题

```python
async def send_packet_menu_callback(...):
    # User 在文件顶部已导入
    
    # 第644行：在 try 之前引用 User
    _user_class = User  # ✅ 这应该能工作
    
    try:
        # 第651行：在 try 块中使用 User
        db_user = db.query(User).filter(User.tg_id == user_id).first()
        # ... 更多使用 User 的地方 ...
        
    except Exception as e:
        # 第876行：在 except 块中导入 User
        from shared.database.models import User as UserModel  # ❌ 这里出错！
```

### 3. 为什么 `_user_class = User` 不够？

虽然 `_user_class = User` 在 `try` 之前，但问题是：

1. **Python 的编译时分析**：Python 在编译函数时，会分析整个函数的作用域
2. **try 块中的使用**：在 `try` 块中多次使用 `User`（第651、657、839、859行）
3. **except 块中的导入**：在 `except` 块中尝试导入 `User as UserModel`
4. **冲突**：Python 可能认为 `User` 是局部变量，但导入语句试图将其作为模块导入，导致冲突

### 4. 真正的解决方案

**方案1：在函数开始处就引用 User（推荐）**

```python
async def send_packet_menu_callback(...):
    # 在函数最开始就引用 User，确保 Python 知道它是外部作用域的
    _ = User  # 或者 User.__name__ 等任何引用
    
    # ... 其他代码 ...
    
    try:
        # 现在可以安全使用 User
        db_user = db.query(User).filter(...)
        
    except Exception as e:
        # 在 except 块中使用别名，避免任何冲突
        from shared.database.models import User as UserModel
        # 使用 UserModel 而不是 User
```

**方案2：在 except 块中完全避免使用 User 名称**

```python
except Exception as e:
    # 使用完全不同的名称，避免任何冲突
    import sys
    UserModel = sys.modules['shared.database.models'].User
    # 或者
    from shared.database import models
    UserModel = models.User
```

**方案3：使用 global 声明（不推荐，但可以）**

```python
async def send_packet_menu_callback(...):
    global User  # 明确声明 User 是全局变量
    # ...
```

## 推荐修复

最佳方案是在函数最开始就引用 `User`，并且确保在 `except` 块中使用不同的名称：

```python
async def send_packet_menu_callback(...):
    # 在函数最开始就引用 User，确保 Python 知道它是外部作用域的
    # 这必须在任何 try/except 之前
    _ = User  # 或者 User.__name__ 等任何引用
    
    # ... 其他代码 ...
    
    try:
        # 使用 User
        db_user = db.query(User).filter(...)
        
    except Exception as e:
        # 使用完全不同的名称，避免任何冲突
        from shared.database.models import User as UserModel
        # 使用 UserModel
```
